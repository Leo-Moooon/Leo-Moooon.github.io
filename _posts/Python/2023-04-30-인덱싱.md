---
title: "인덱싱과 자료 조작"
categories:
  - Python
tags:
  - 인덱싱
  - list
  - dictionary
  - DataFrame
toc: true
toc_sticky: true
toc_label: "페이지 목차"
---

행, 열 내 원하는 데이터에 접근하는 방법이 자료형마다 차이가 있어서 이를 중심으로 정리하고자 한다.

## 리스트(List)
```
list1 = ['1번', '2번', '3번', '4번']
```
여기서 '3번'에 접근해보자.
```
list[2]
# 출력결과: '3번'
```
### 값 변경
`list1[2] = 'new'`<br>
```
#list1의 출력결과
['1번', '2번', 'new', '4번']
```

### 값 삭제
`del list1[3]`<br>
```
#list1의 출력결과
['1번', '2번', '3번']
```

### 값 삭제2
`list1.remove('2번')`<br>
```
#list1의 출력결과
['1번', '2번', '4번']
```
해당 값이 여러 개 존재한다면, 첫 번째로 도달하는 값을 삭제한다.

### 값 추가1
`list1.append('appended')`<br>
```
#list1의 출력결과
['1번', '2번', '3번', '4번', 'appended']
```
이 때 새로 추가된 값은 리스트의 마지막에 위치한다.

### 특정 인덱스에 값 추가
`list1.insert(0, '0번')`<br>
0번째 인덱스에 '0번'을 넣는다.
```
#list1의 출력결과
['0번', '1번', '2번', '3번', '4번', 'appended']
```

### 정렬
`list1.sort(reverse=True) #내림차순`<br>
```
#list1의 출력결과
['4번', '3번', '2번', '1번']
```
기본값은 `reverse=False`이다.

### 순서 뒤집기
`list1.reverse()`<br>
```
#list1의 출력결과
['4번', '3번', '2번', '1번']
```

### 특정 값의 인덱스 확인
`list1.index('1번')`<br>
```
#출력결과
3
```

### 값 추출
`list1.pop()`<br>
이 때 원본은 훼손되지 않으며, 추출된 값은 변수에 담아서 사용할 수 있다.

인덱스로 추출할 값을 지정할 수 있으며, 미지정 시 마지막 요소가 추출된다.

#### 활용
```
list1 = list1 = ['1번', '2번', '3번', '4번']
a = list1.pop()
print(a)

#출력결과: 4번
```

### 특정 값의 개수 세기
`list1.count()`<br>
동일한 값이 여러 개 존재할 때 해당 값의 개수를 셀 수 있다.<br>
함수 안에 인자로 어떤 값을 셀지 지정해줘야 한다.


### 리스트 병합
`list1.extend(['x', 'y', 'z'])`<br>
이 때 병합되는 리스트는 list1 뒤에 이어진다.

***

## 튜플(Tuple)
`tu1 = ('a', 'b', 'c', 'd')`<br>

튜플은 리스트와 다르게 값을 변경, 삭제, 추가할 수 없다.<br>
기본적으로 원본을 해치지 않는 인덱싱, 슬라이싱 정도가 가능하다. 그 외에도 원본을 해치지 않기 때문에 가능한 덧셈, 곱셈이 있다.

### 인덱싱
방법은 위의 리스트와 동일하다.
```
print(tu1[3])
#출력 결과: d
```
### 슬라이싱
슬라이싱은 리스트에서도 동일하게 사용 가능하다.<br>
`tu1[x:y:z]` : x번부터 y번 전까지, z씩 인덱스 증가. <br>
 - x 생략 시: 처음부터 y번 전까지
 - y 생략 시: x번부터 끝까지
 - z 생략 시: (기본값)1 간격

```
tu1[1:3] # 인덱스 1~2까지 가져오기
tu[2:] #인덱스 2부터 끝까지 가져오기
tu[2::2] #인덱스 2부터 끝까지 2 간격으로 가져오기
tu[::] #처음부터 끝까지 가져오기
tu[::-1] #처음부터 끝까지 거꾸로 가져오기
tu[3:1:-1] #인덱스 3~2번 가져오기
```

### 튜플 덧셈
```
a = (1, 2, 3)
b = (4, 5, 6)
print(a+b)

#출력 결과
(1, 2, 3, 4, 5, 6)
```

### 튜플 곱셈
```
a = (1, 2, 3)
print(a * 3)

#출력 결과
(1, 2, 3, 1, 2, 3, 1, 2, 3)
```
### 튜플을 리스트로 변환하기
`list(tu1)`

## 딕셔너리(Dictionary)
```
dic = {"이름" : "홍길동", "성별" : "남자", "나이" : 20}
```

| Key | Value |
|:---|:---|
| 이름 | 홍길동 |
| 성별 | 남자 |
| 나이 | 20 |

### 특징
- 무조건 Key값을 기준으로 접근한다.
- 집합형태라서 순서가 없다.
- Key값으로 리스트를 쓸 수 없다(튜플은 가능하다).
- Key값은 중복될 수 없다.

### 값 추가 및 변경
Key, Value 쌍을 맞춰줘야 한다.<br>

딕셔너리에 존재하지 않는 Key값을 지정하면 새 값이 추가되고, 존재하는 Key값을 지정하면 해당 값의 Value값이 변경된다.
```
dic['취미'] = "음악 듣기"
print(dic)

#출력
{'이름': '홍길동', '성별': '남자', '나이': 20, '취미': '음악 듣기'}
```
```
dic['나이'] = 30
print(dic)

#출력
{'이름': '홍길동', '성별': '남자', '나이': 30}
```

### 값 삭제
```
del dic['나이']

#출력
{'이름': '홍길동', '성별': '남자'}
```

### 값 존재여부 확인
앞서 언급한대로 여기서 값은 Key값을 말한다.<br>

부울 값을 반환한다.
```
print("이름" in dic)

#출력
True
```

### Key에 대응하는 Value에 접근
```
print(dic["이름"])

#출력
'홍길동'
```

### Key만 모아보기 + 리스트로 변환
`dic.keys()`<br>
```
print(dic.keys())

#출력
dict_keys(['이름', '성별', '나이'])
```

이 때 자료형은 `dict_keys`로 조회가 되고, 필요 시 `list()`에 담아 리스트로 변환할 수 있다.

### Value만 보아보기 + 리스트로 변환
`dic.values()`<br>
```
print(dic.values())

#출력
dict_values(['홍길동', '남자', 20])
```

`keys()` 때와 마찬가지로 이 때 자료형은 `dic.values`로 조회가 되고, 필요 시 `list()`를 통해 리스트로 변환할 수 있다.

### Key: Value로 묶어서 보기 + 리스트로 변환
`dic.items()`<br>
```
print(dic.items())

#출력
dict_items([('이름', '홍길동'), ('성별', '남자'), ('나이', 20)])
```

이 또한 `list()`를 이용해서 리스트로 변환이 가능하며, 모습은 다음과 같다.
```
list2 = list(dic.items())
print(list2)

#출력
[('이름', '홍길동'), ('성별', '남자'), ('나이', 20)]
```
이 때 각 요소는 튜플로 저장된다.
```
print(type(list2[0]))

#출력
tuple
```


## 집합(Set)
- 집합 내에서는 요소 간 중복이 허용되지 않는다.
- 순서가 없다.

```
s1 = set('Hello World!')
s2 = set([1, 1, 2, 5, 3, 4, 2, 2, 2])

print(s1)
print(s2)

#출력
{' ', 'e', '!', 'd', 'o', 'W', 'H', 'r', 'l'}
{1, 2, 3, 4, 5}
```

### 교집합
`&` 연산자를 이용해 교집합을 구할 수 있다.

```
s1 = set([1, 2, 3, 4, 5])
s2 = set([1, 3, 5, 7, 9])

print(s1 & s2)

#출력
{1, 3, 5}
```

### 합집합
`|` 연산자를 이용해 교집합을 구할 수 있다.
```
s1 = set([1, 2, 3, 4, 5])
s2 = set([1, 3, 5, 7, 9])

print(s1 | s2)

#출력
{1, 2, 3, 4, 5, 7, 9}
```

### 차집합
`-` 연산자를 이용해 교집합을 구할 수 있다.
```
s1 = set([1, 2, 3, 4, 5])
s2 = set([1, 3, 5, 7, 9])

print(s1 - s2)

#출력
{2, 4}
```

### 하나의 값 추가
`add()`를 이용해 교집합을 구할 수 있다.
```
s1 = set([1, 2, 3, 4, 5])
s1.add(6)
s1.add(0)

print(s1)

#출력
{0, 1, 2, 3, 4, 5, 6}
```

### 여러 값 추가
`update()`를 이용하되, 인자로 리스트나 튜플로 여러 값을 한 번에 추가할 수 있다. 이때 중복값은 알아서 제거된다.
```
s1 = set([1, 2, 3, 4, 5])

s1.update([1,2,3,6])
print(s1)

#출력
{1, 2, 3, 4, 5, 6}
```

### 값 제거
`remove()`를 이용하되, `update()`와 달리 한 번에 하나의 값만 제거할 수 있다.
```
s1 = set([1, 2, 3, 4, 5])

s1.remove(1)

print(s1)

#출력
{2, 3, 4, 5}
```

### 여러 값 제거
여러 값을 제거해야 한다면, `-=` 연산자를 이용해 뺄 수 있다. 이 때 빼는 값도 집합이어야 한다.
```
s1 = set([1, 2, 3, 4, 5])

s1 -= {1, 2}

print(s1)

#출력
{3, 4, 5}
```


## 시리즈(pandas.Series)
리스트와의 가장 큰 차이점은 시리즈에는 인덱스 이름을 부여할 수 있다는 것이다.

### 리스트 -> 시리즈 (인덱스 이름 미지정)

```
import pandas as pd

box = ['a', 'b', 'c', 'd', 'e']
ss = pd.Series(box)
```

|---|---|
|0|a|
|1|b|
|2|c|
|3|d|
|4|e|


### 리스트 -> 시리즈 (인덱스 이름 지정)

```
import pandas as pd

box = ['a', 'b', 'c', 'd', 'e']
ss = pd.Series(box, index = ['1행', '2행', '3행', '4행', '5행'])

print(ss)
```

|---|---|
|1행|a|
|2행|b|
|3행|c|
|4행|d|
|5행|e|

### 시리즈 -> 데이터프레임
`ss.to_frame()`

### 시리즈 행 이름 확인
`ss.index`로 행 이름을 받아볼 수 있으며, 리스트처럼 인덱싱도 가능하다.

```
import pandas as pd

box = ['a', 'b', 'c', 'd', 'e']
ss = pd.Series(box, index = ['1행', '2행', '3행', '4행', '5행'])

ss.index[2]

#출력
'3행'
```

### 시리즈 값 확인
`ss.values`로 값을 받아볼 수 있으며, 리스트처럼 인덱싱도 가능하다.

```
import pandas as pd

box = ['a', 'b', 'c', 'd', 'e']
ss = pd.Series(box, index = ['1행', '2행', '3행', '4행', '5행'])

ss.values[2]

#출력
'c'
```

### 시리즈 통계함수

| 통계함수 | 설명 |
|:--------------|:---|
| s.mean()     | 평균 |
| s.std()      | 표준편차 |
| s.median()   | 중앙값 |
| s.describe() | 요약 통계량 |
| s.max()      | 최대값 |
| s.mean()     | 최소값 |

## 데이터프레임(pandas.DataFrame)
```
import pandas as pd

df = pd.DataFrame({'이름': ['피터', '브루스', '스티브'],
                   '지역': ['퀸스', '고담', '브루클린'],
                   '나이': [21, 40, 70]})
```

|   | 이름 | 지역   | 나이     |
|---|------|--------|----------|
|   | 피터 | 브루스 | 스티브   |
|   | 퀸스 | 고담   | 브루클린 |
|   | 21   | 40     | 70       |

### 열에 접근하기
특정 열의 값들을 뽑아보고 싶다면 `df[<열 이름>]`으로 해당 열에 접근할 수 있다.
```
import pandas as pd

df = pd.DataFrame({'이름': ['피터', '브루스', '스티브'],
                   '지역': ['퀸스', '고담', '브루클린'],
                   '나이': [21, 40, 70]})
df['이름']
```

|   | 이름  |
|---|-----|
| 0 | 피터  |
| 1 | 브루스 |
| 2 | 스티브 |


만약 여러 열에 한 번에 접근하고 싶다면 대괄호[] 안에 리스트로 담아주면 된다.

### 행, 열에 접근하기
```
# 행 접근
df.loc[0] #df에서 이름이 0인 행(인덱스)에 접근
df.iloc[0] #df에서 0번째 행에 접근

df.loc[[0,1]] #df에서 이름이 0, 1인 행(인덱스)에 접근
df.iloc[[0,1]] #df에서 0번째, 1번째 행에 접근


# 행 열 접근
df.loc[0,2] #df에서 이름이 0인 행, 2인 열에 접근
df.iloc[0,2] #df에서 0번째 행, 2번째 열에 접근

df.loc[[0, 1] ,[1, 2]] #df에서 이름이 0, 1인 행(인덱스)과 1, 2인 열에 접근
df.iloc[[0, 1] ,[1, 2]] #df에서 0, 1번째 행(인덱스)과 1, 2번째 열에 접근

# 특정 열을 기준으로 행에 접근
df['이름'][2] # '이름'열에서 2번째 행에 접근
```

### 조건에 부합하는 행 추출하기
```
#df[조건1]
df[df['나이'] >= 30] # '나이' 열에서 값이 30 이상인 행만 추출

#df[조건1 & 조건2]
df[(df['지역'] != '고담') & (df['나이'] >= 30)] # '지역' 열에서 '고담'이 아니면서 '나이' 열에서 값이 30 이상인 행만 추출

#df[조건1 | 조건2]
df[(df['지역'] != '고담') | (df['나이'] >= 30)] # '지역' 열에서 '고담'이 아니거나 '나이' 열에서 값이 30 이상인 행만 추출

```

### 모양, 정보 확인하기
`df.columns`: 열 이름 확인<br>
`df.shape`: 몇 행 몇 열인지 확인<br>
`df.dtypes`: 각 열의 데이터 타입 확인<br>
`df.info`: 데이터프레임의 정보 확인(각 열의 데이터 타입, 메모리 사용량 등)

### 시리즈 및 데이터프레임의 중복데이터 삭제하기
`ss.drop_duplicates()` : 중복되는 값 제거 <br>

`df.drop_duplicates()` : 중복되는 행 제거하고 고유한 값만 남긴다. <br>

|   | number | string |
|---|--------|--------|
| 0 | 1      | a      |
| 1 | 1      | b      |
| 2 | 2      | b      |
| 3 | 3      | c      |

```
#모든 열에 대해 중복되는 데이터 제거
df.drop_duplicates()
```

|   | number | string |
|---|--------|--------|
| 0 | 1      | a      |
| 1 | 1      | b      |
| 2 | 2      | b      |
| 3 | 3      | c      |

number와 string에 대해 동시에 중복되는 행이 없어서 아무것도 삭제되지 않았다.

```
df.drop_duplicates(['string'])
``` 

|   | number | string |
|---|--------|--------|
| 0 | 1      | a      |
| 1 | 1      | b      |
| 3 | 3      | c      |

string을 기준으로 1, 2행은 겹치는 데이터라서 중복제거가 되었다.

### 시리즈 특정 값 바꾸기
`ss.replace(값, 변경값)` <br>

이를 데이터프레임에서 다음과 같이 사용할 수 있다.
```
df['string'] = df['string'].replace('c', 'f') # string 열에서 c의 값을 f로 바꾸고, 이 결과를 string 열에 새로 할당한다.
```

|   | number | string |
|---|--------|--------|
| 0 | 1      | a      |
| 1 | 1      | b      |
| 3 | 3      | f      |

